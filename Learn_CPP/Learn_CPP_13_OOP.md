- [Object Oriented Programming](#object-oriented-programming)
- [Classes](#classes)
  - [Access Specifiers](#access-specifiers)
  - [Encapsulation](#encapsulation)
  - [Constructors](#constructors)
  - [Nested Classes](#nested-classes)
  - [Member Initializer List](#member-initializer-list)
    - [Setup With Member Function](#setup-with-member-function)
  - [Resetting an Instance](#resetting-an-instance)
  - [Destructor](#destructor)
    - [Member Function Chaining Using ``This``](#member-function-chaining-using-this)
  - [Anonymous Objects](#anonymous-objects)
  - [Nested Types](#nested-types)
  - [Timing](#timing)
  
# Object Oriented Programming
- defining and creating objects whose properties and behaviors are self-contained
  - easier to understand
  - more reusable

# Classes
- ``struct``s that also hold behavior
- ``declaration``
  - ```c++
    class Date {
    public:
        int year{};
        int month{};
        int day{}
    };
    ```
- member functions (methods)
  - ```c++
    class Date{
    public:
        // ...
        void print() {
            std::cout<< ... ;
        }
    };
    ```
  - methods can be accessed through the member selection operator ``operator.``
  - methods have *implicit object* of the class instance itself, meaning that there is no need for explicitly defining and referencing ``self`` as in ``Python``
  - methods do not need forward declarations to reference other methods in teh same class (i.e. the order of declaration of each method is irrelevant within the class)
  - note that in ``C++``, unlike ``C``, ``struct``s can have member functions as well
    - however it is not exactly best practice to put member functions in ``struct``s which are usually reserved for data-only objects that *do not clean up* themselves
- name member variables with ``m_`` prefix
- name classes with upper camel case
- member types
  - type aliases within the class
    ```c++
    class Character {
        using health_type = int;
    };

    // ...
    Character::health_type hp{0};
    ```
  - in this scenario, it is common to use a ``_type`` or no suffix instead of ``_t``

## Access Specifiers
- member of a ``struct`` are ``public`` by default
  - the top level area of a file is called ``the public`` and it can only access the publically exposed members of the structs and classes in it
- members of a ``class`` are ``private`` by default
- generally member variables are kept ``private`` while member functions are kept ``public``
- a
  
## Encapsulation
- information hiding
- make member variables private and use public getter/setters to operate, only if needed
> provided examples are generally covered by intro to OOP/Java, skipped

## Constructors
- a special function called upon instantiation of a class, produces an instance in a *well defined*, *usable* state
  - constructors don't *create* the object, the creation happens before the constructor is even called (during which memory allocation, etc., happens), and the constructor only handles uits initia,ization
- **default constructor**
  - called if no user-provided values exist
  - ```c++
    class Fraction {
        private:
        int m_num, m_denom;
        public:
        Fraction() {
            m_num = 0;
            n_denom = 1;
        }
    };

    // ...
    Fraction f{}; // value initialization
    Fraction f1; // default constructor called
    ```
  - zero-initialization of a class member clears its entire memory (allocated at instantiation), which is inefficient
  - default constructor must be explicitely stated
  - ``Fraction f;`` will cause undefined behavior since associated default constructor does not exist
    - it is unsafe to use default constructors for this reason
    - if using default constructor, always check if that class actually has a defautl constructor
- constructors can be overrided by having different parameter types
- constructors with parameters can be used with list initializers
  - ```c++
    Fraction(int m, int n = 1) {
        // ...
    }
    // ...
    Fraction f{1, 2}, g{3}; // 1/2, 3/1 using brace init.
    Fraction p(1, 2), q(3); // 1/2, 3/1 using parenthesis
    ```
  - favor list initializer over parenthesis
  - copy initialization
  - ```c++
    Fraction h = Fraction{2}; // 2/1 which calls Fraction(2, 1)
    Fraction r = 1; // 1/1 which calls Fraction(1, 1)
    ```
- unlike array initialization, missing parameters in the bracket initializer are not always filled by default value
  - the compiler matches a cloeset constructor, filling in default values only if they were defined as having default in the constructor
- cannot skip non-right-most parameters
  - ```c++
    IntDouble(int a = 0, double b = 1.0) {
        // ...
    }
    // ...
    IntDouble i{2.2}; // illegal, @a skipped
    ```
- **implicit constructor**s are generated by the compiler when a class does not have any other constructor
  - can be invoked with bracket initialization
  - must not have parameters
- to force a default constructor to be generated, use
  - ```c++
    MyClass() = default; // manually generated default constructor
    MyClass(int p1, char p2) {
        // ...
    }
    ```
  - default is longer but clearer than an empty body
## Nested Classes
- class typed members (``class``members that has a ``class`` as their type, as opposed to ``struct`` or any primitive) are automatically initialzied

## Member Initializer List
- follows the constructor parameter list
- ```c++
  // initializer list with literals
  Player(): m_hp{100}, m_gold{0} {
      // more complicated stuff
  }

  // initializer list with parameters
  Player(int hp, int gold = 0): m_hp{ hp }, m_gold{ gold } {
      // more complicated stuff
  }
  ```
  - for simple assignment, replace them with initializer list
  ### Member Initializer List with Arrays
  - prior to ``C++11``, array typed members can only be initialized to zero
  - since ``C++11``, array typed members in an initializer list can use the same initialization formats as normal variables
    ```c++
    private:
    const int m_array[8];
    public:
    IntFlag(): m_array { 37, -2, 0 } {
        // ...
    }
    ```
  ### Member Initializer List with Class Typed Members
  - constructors can be invoked by the bracket initializer within the initialier list
    ```c++
    private:
    Fraction f;
    // ...
    public:
    FractionAndSomethingElse(): f{ 2, 3 } { // calls Fraction(2, 3)
        // ...
    }
    ```
- variables in the initializer list are initialized based on the order by which they are defined within the class, not by their order within the initializer list itself

## Non-Static Member Initialization
- aka in-class member initializer
- provides default values for member variables
    ```c++
    private:
    int m_num{0};
    int m_denom{1};

    public:
    Fraction(int num, int denom) {
        // ...
    }
    ```
- note that because there is no default constructor, the default values won't actually be used because the only way to instantiate is ``FractioN(n, d)``
- non-static member initialization requires either the copy initializer ``=`` or brace initializer ``{}``, but not parenthesis initializer ``()``
- initializer lists will also take precedence over default initialization

## Overlapping/Delegating Constructors
- ``C++`` does not support constructor invocation within another constructor like ``Java``
- when calling a constructor within another constructor, a separate class instance is created and then immeidiately discarded
### Delegating Constructor
- aka. constructor chaining
- call the constructor within the initializer list
- go from less to more params
  ```c++
  Fraction(int numerator) {
      m_numerator = numerator;
      m_denominator = 1;
  }

  Fraction(int numerator, int denominator): Fraction{numerator} {
      m_denominator = denominator;
  }
  ```
- go from more to less params
  ```c++
  Fraction(int numerator): Fraction{numerator, 1} {}
  Fraction(int numerator, int denominator) {
      // ...
  }
  ```
- skip unnecessary default params on th eleft
  ```c++
  Player(int hp = 100, int gold = 0) {
      // ...
  }
  // usually the default params on the left cannot be skipped
  Player(int gold) : Player{ 100, gold } {}
  ```
### Setup With Member Function
- the constructor invokes member functions to handle setup
  ```c++
  private:
  // ... member values
  void setup() {
      // ...
  }

  public:
  Player( int a, int b, int c ) {
      // setup members
      // ...

      // the member function cannot initialize, it can only assign
      setup();
  }
  ```
  - cannot initialize means it cannot do things like binding references or providing first-time values for ``const``
## Resetting an Instance
```c++
class ResetClass {
    private:
    // members
    public:
    // constructors
    void reset() {
        *this = ResetClass(); // replace the memory it occupies
    }
};
```
## Destructor
- executed when the instance is destroyed
  - statically instantiated and then goes out of scope
  - dynamically instantiated and then ``delete``d
- normally, if the class only holds values, then there is no need for destructor as ``C++`` wipes the instance's memory automatically
- however, other responsibilities like deallocating dynamic memory and closing file streams need to be done manually
- there can only be one destructor per class
  - named ``~``+classname
  - with no parameters
  - with no return value
- ```c++
  class Classroom {
      private:
      Student* students;
      public:
      Classroom(int nStudents) {
          students = new Student[static_cast<std::size_t>(nStudents)]{};
      }
      // following are for muting compiler errors, will be explained in 14
      Classroom(const Student&) = delete;
      Classroom& operator=(const Student&) = delete;

      ~Classroom() {
          delete students;
      }
  };
  ```
- note that the ``exit`` funtion quits the program immediately without calling destructors

## RAII Principle
- resource acquisition is initiailization
  - ties the lifetime of objects with its resource use
  - in ``C++``, this is implemented with ``class`` constructors and destructors

## ``This`` Pointer
- the compiler converts member invocations to be of ``this->``
- member functions are converted to ``foo(MyClass* const this, regularParams) {}``
  - basically how ``Python`` member functions are normally written
- ``this`` alwyas points to the current instance, different between different instance's invocations
- similar to ``Java``, ``this`` can be referenced explicitly to avoid naming collision
  ```c++
  class Player {
      private:
      // ...
      public:
      Player(int hp) {
          this->hp = hp;
      }
  };
  ```
### Member Function Chaining Using ``This``
- ```c++
  class Player() {
      public:
      Player& walk(){
          return *this; // return the content pointed by the this pointer
      }
  };
  //
  player
      .walk()
      .walk()
      .walk();
  ```
  - an operator overload version of this is in chapter 14
## Class Header Files
- member functions, constructors, and destructors can be defined outside of a class, provided they are prefixed with the class name
    ```c++
    class Classroom {
        private:
        Student* m_students;
        public:
        Classroom(int nStudents);
        void AddStudent(Student student); // note that this uses upper camel case
        ~Classroom();

        Student getStudent(int index) { // note that this is lower camel case
            // ...
        }
    };

    Classroom::Classroom(int nStudents) {
        // ...
    }

    void Classroom::AddStudent(Student student) {
        // ...
    }

    void Classroom::~Classroom() {
        // ...
    }
    ```
- by this point, we can split the class definition to a header file (``.h``) and all the member function implementations to a ``.cpp`` file
    - the ``.cpp`` file should include the ``.h`` file
    - there can be multiple ``.cpp`` files implementing the same class defined in the header
- member functions can be defined simultaneously in the header file and some ``.cpp`` file, the version in the header is implicitly ``inline``
  - the reason for favoring changing ``.cpp`` is that only the changed ``.cpp`` itself needs to be re-compiled
    - whereas, if the header file were to be changed, all the files that ``include`` the header must also be recompiled
- recommended practice is to
    - for low reuse, defined entire class in ``.cpp``
    - for high reuse, define in ``<classname>.h`` and maybe split the implementation to separate ``.cpp`` files depending on the complexity
    - trivial member functions (one-liners, typically) stay in the header
    - non-trivial member functions go to the ``.cpp`` file
    - define default parameters in the header file
        - this ensures visibility to whoever ``include``s the header
    - when shipping libraries, include the precompiled library file instead of the ``.cpp`` files that expose your implementation
        - unles the project is open source

## ``Const`` Class Objects & Member Functions
- a ``const`` instance variable of some ``class`` cannot have its member values modified
  - not even if the modification is done by a ``class`` member function
- a ``const`` instance variable cannot have member functions invoked unless they are marked ``const``
  - in general, getter functions should be marked ``const`` as they do not modify the value
  - the ``const`` keyword for a member function promises the compiler that it will not modify the object
    - ``const`` member functions are not allowed to invoke non-``const`` member functions
    - ``const`` member functions are not allowed to change member values (*ex.* ``health--;``)
    ```c++
    class Fraction {
        // ...
        public:
        double getFloatingPoint() const { return static_cast<double>(m_numerator) / m_denominator; }
    };
    ```
- constructors can never by marked ``const``
- in functions, use ``const`` reference to promise the parameter will not be changed
    - ``const`` referenced parameters can only have their ``const`` member functions invoked
- functions that differ only by their ``const``-ness are considered distinct overloads
  - typically this is done to differ the ``const``-ness of their return value

## ``Static`` Members
### Variables
- shared by all objects of the class
- can be accessed through
  - ``ClassName::staticVariableName``
  - ``variableName.staticVariableName``
- the convention is to use ``s_`` prefix when naming ``static`` variables, and access them under the class name to avoid confusion
- placement
    - if the ``class`` is defined in a ``.h`` file, the `static` variables are usually placed in the `.cpp` file
    - otherwise, place the `static` variables directly under the `class` and make them `public`
- initialization
    - ``static const`` members can be initialized directly inside the class definition if it is integral
        - ```static const int s_value{ 4 };```
    - ``static constexpr`` members can be initialized inside the class definition as well
        - ```static constexpr double s_value{ 2.2 };```
    - since `C++17`, other members can also be initialized as long as they are `inline`
        - ```static inline int sa-value{ 4 };```

### Functions
- similar to that in `Java`
    - no `this`, no access to member variables unless passed as arg or initialized within the function
-   **monostates**
    - aka. pure static classes
    - all members are static
- `C++` has no `static` constructors

## Friend Functions and Classes
- a `friend` function exposes private members of the class
  ```c++
  class Account {
      // ... other public and private members
      friend void reset(Account& account);
  };

  void reset(Account& account) {
      // access private members here
      account.m_balance = 0;
  }
  ```
- `friend` function for multiple classes
  ```c++
  class Account {
      // ...
      friend void associate(Account& account, Bank& bank);
  };

  class Bank {
      // ...
      friend void associate(Account& account, Bank& bank);
  };

  void associate(Account& account, Bank& bank) {
      // ...
  }
  ```
- `friend` `class`
  - can access all private information with another `class`
  ```c++
  class Account {
      // ...
  };

  class Bank {
      // ...
      friend class Account;
  };
  ```
    - note that this is one-sided
    - sadly, `friend`ship is not symmetric or transitive, at least not in `C++`
  - `friend` member functions
    - the other `class` can only access private information within `friend` member functions (unless it is a `friend` class)
    - use `friend ClassName::methodName`
    > declaring `friend` classes in the same `.cpp` file is really messy, the article describes how to do it but it will be skipped because it's not good practice anyway
      - use header files instead so that all member definitions are instantly visible
    - given `A` `friend`s `B`'s member function single sidedly, the following should happen
      - in `A.h`, `include` `B`'s header within the guards, this way `B`'s member function can be seen
      - in `A.cpp`, `include` `A`'s header to implement other member functions of `A`
      - in `B.h`, use a forward declaration of `class A` to make the class itself visible, but no need to make members visible by `include`
      - in `B.cpp`, `include` both `A` and `B`'s headers to view both `class`' members

## Anonymous Objects
- temporary and not actually stored to any variable
  - ```c++
    Animal dog{}; // named
    Animal{}; // anonymous
    ```

## Nested Types
- classes act as a name scope
- determine the visibility of nested classes, make `public` only if necessary
  - for example if the neested type is returned or taken as parameter for `public` member functions (from outside), then the nested type must be `public`
  - note that, as previously mentioend, `enum`s have global naming, so `MyClass::MyNestedEnum::enum_category` can be shortened to `MyClass::enum_category`

## Timing
> the article describes a wrapper class for the \<chrono\> library, available since C++ 11
> it uses `std::chrono::stady_clock::now()`, which returns a time value that can be cased to `std::chrono::duration<double, std::ratio<1>>` using `std::chrono::duration_cast<>` and then operated arithmetically
> the wrapper has `reset` and `elapsed` member functions
- to make timing accurate
  - use the release build to ensure all optimizations are included
  - quit other processes in the system
  - measure multiple times
  - be aware of randomized data