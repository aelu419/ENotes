- [Creating the App](#creating-the-app)
- [Navigation](#navigation)
  - [file structure based routing](#file-structure-based-routing)
  - [clent-side navigation](#clent-side-navigation)
- [Assets, Metadata, CSS](#assets-metadata-css)
  - [Assets](#assets)
  - [CSS](#css)
- [Pre-Rendering and Data Fetching](#pre-rendering-and-data-fetching)
  - [Static Generation Without Data](#static-generation-without-data)
  - [Static Generation With Data](#static-generation-with-data)
  - [Server Side Rendering](#server-side-rendering)
  - [Client Side Rendering](#client-side-rendering)
- [Dynamic Routes](#dynamic-routes)

# Creating the App
- `create-next-app`, using the `nextjs-blog` template and several other configurations

# Navigation

## file structure based routing
  - `pages/<rel>.jsx` is by default mapped to `/rel`
  - *ex.* [example routed page](2.simple/nextjs-blog/pages/frouted.jsx)
  - use of the `Link` component as alternative to `a` (for routes within the app)

## clent-side navigation
  - enabled by using `Link`
  - doesn't reload the webpage, just replaces DOM elements with JS (completely on client side)
  - in contrast `a` does cause page reload
  - the `Link` tag signals for code pre-fetching (from the destination module) to the Next compiler

# Assets, Metadata, CSS

## Assets
- images are optimized at runtime, not build time
  - fits different devices
  - `Image` component
  - extension of the html `img` tag with props
  - note that image optimization is not possible for static sites (unless with vanilla NextJS)
- `Head` component as replacement of the HTML `head` tag
  - metadata (title, icon, etc.)
  - internal tags of `Head` work the same as `head`
- the `html` tag itself can be modified from `pages/_document.jsx`
- third party JS
  - `Script` component from `next/script` that replaces the html `script`
  - `Script`s can be specified
    - with `src`
    - with the `lazyOnload` strategy (`strategy` prop field)
    - with some function for `onLoad`
## CSS
  - import global CSS in `_app.js`
    ``` jsx
    import '../styles/global.css'

    export default function App({Component, pageProps}) {
      return <Component {...pageProps} />;
    }
    ```
  - import local CSS in component module
    - `import styles from ./Home.module.css`
    - for classes, use something like `styles.container` instead of `container`
    - class names are distinguished by module name (automatically generated)
    - alternatively, use `style` tag
      ``` jsx
      <style jsx global>
      <!-- ... -->
      </style>
      ```
  - for specific `id`'s use embedded style or global style instead of module
    - inside the tag, use `style` tag
    - *ex.*
      ``` jsx
      <style jsx>
      <!-- ... -->
      </style>
      ```
  > the tutorial goes over font specifications in CSS
  - the **classnames** library
    - multiple classnames per component
    - *ex.*
      ``` jsx
      import styles from './alert.module.css';
      import cn from 'classnames';

      export default function Alert({ children, type }) {
        return (
          <div
            className={cn({
              [styles.success]: type === 'success',
              [styles.error]: type === 'error',
            })}
          >
            {children}
          </div>
        );
      }
      ```
- more metadata can be carried in `meta` tags to be parsed, although not rendered


# Pre-Rendering and Data Fetching
- how to check if elements are pre-rendered?
  - disable JS, all pre-rendered components are in HTML

## Static Generation Without Data
- when building for production, pages that do not require external data are *automatically* marked for static generation

## Static Generation With Data
- note that this is data fetch at build time, not runtime
- use `getStaticProps` along the component itself
  - *ex.*
    ``` jsx
    export default function Home(props) { ... }

    export async function getStaticProps() {
      const data = ...
      return {
        props: ...
      }
    }

    ```
  - here, `getStaticProps` fetches the availalbe data at build time, and those are passed to the `Home` component to be pre-rendered

> the example uses the **gray-matter** library for parsing markdown content
>   - post data are fetched from local directory into an array/dictionary
>   - that array/dictionary is put into `props` which is returned by `getStaticProps`
>   - `Home` uses that array/dictionary from `props`

- alternatively, use external API/database (preferably in `async` manner since `getStaticProps` supports asynchronous)
- in *development* `getStaticProps` runs per request
- in *production* itt runs at build time (with optional runtime fallback)
- `getStaticProps` can only b3e exported from a *page* module, not something like a component that isn't actually individually paged
  - NextJS requires all relevant static data to be fetched before the page renders

## Server Side Rendering
- similarly, uses `export async function getServerSideProps(context)`
  - only use server side rendering if the page data *must* be determined at request-time
  - generally slower than `getStaticProps` because the server needs to perform computation upon request

## Client Side Rendering
- commonly used along with non-data-based static generation
  - this is when SEO is not actually relavant
  - user dashboards, etc.
- **React SWR**
  - handles caching, revalidation, etc.
  - *ex.*
    ``` jsx

    import useSWR from 'swr';

    function Profile() {
      const { d, e } = useSWR('/api/user', fetch);

      if (e) return ...
      if (!d) return ...
      return ...
    }

    ```


# Dynamic Routes
- 